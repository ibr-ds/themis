use futures_util::stream::{FusedStream, Stream, StreamExt};
use serde::{Deserialize, Serialize};
use std::{borrow::Cow, fmt::Debug, future::Future, ops::Range};
use thiserror::Error;

use crate::{
    app::{Client, Request, Response},
    comms::Receiver,
    net::{AuthenticationKind, Message, Raw, Tag},
};

pub mod quorum;
pub mod single_class_quorum;
mod slots;
use crate::protocol::batching::{BatchConfig, Batcher};
use futures_util::future::ready;
pub use slots::Slots;
pub mod batching;
mod proposal;
pub mod window;
pub use proposal::*;
mod checkpointing;
pub use checkpointing::Checkpoint;

/// Base trait to work around the lifetime bound
pub trait Protocol {
    /// Message tag for this protocol
    type Messages: Tag;
    type Event: Send;
    // type Rejection: std::error::Error + 'static;
    // type Error: std::error::Error + 'static;
}

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Debug, thiserror::Error)]
pub enum Rejection {
    #[error("Expeted {field} in {expected:?}, actual {actual}")]
    Range {
        expected: Range<u64>,
        actual: u64,
        field: Cow<'static, str>,
    },
    #[error("Invalid authenticator from {sender}")]
    Authenticator { sender: u64, source: anyhow::Error },
    #[error("Invalid digest from {sender}")]
    Digest { sender: u64 },
    #[error("Structure: {source}")]
    Structure { source: anyhow::Error },
    #[error("State: {reason} ")]
    State { reason: Cow<'static, str> },
    #[error("Duplicate")]
    Duplicate,
}

#[derive(Debug, Error)]
pub enum Error {
    #[error("Message Rejected: {0}")]
    Reject(#[from] Rejection),
    #[error("Protocol Aborted: {}", source)]
    Abort {
        #[from]
        source: anyhow::Error,
    },
}

impl Error {
    pub fn reject<E>(e: E) -> Self
    where
        Rejection: From<E>,
    {
        Self::Reject(e.into())
    }

    pub fn abort<E>(e: E) -> Self
    where
        E: std::error::Error + Send + Sync + 'static,
    {
        Self::Abort {
            source: anyhow::anyhow!(e),
        }
    }
}

/// Second possibility for a protocol trait
/// This can return a Future that borrows self. But I can only get it to work with boxing
/// This implementation requires a lifetime because the returned Future generally want to borrow self
/// In the absence of GATs this seems to be the only way to do this.
/// What we actually want is:
/// trait Protocol {
///     type OnMessage<'a>: Future<Output = Result<()>> + Send + 'a
///     fn on_message(&mut self, message: Message<Raw<Self::Messages>>) -> Self::OnMessage<'_>;
///     // [..]
/// }
/// But this requires GATs, so this workaround exists.
pub trait Protocol2<'a>:
    Send + FusedStream + Stream<Item = Event<<Self as Protocol>::Event>> + Unpin + Protocol
{
    /// Returned Future for handle_message method
    type OnMessage: Future<Output = Result<()>> + Send + 'a;

    /// Handle incoming messages from clients and other replicas#
    /// The message received here will be requests or other messages related to the protocol
    /// The tag field in Message can be used to differentiate messages
    fn on_message(&'a mut self, message: Message<Raw<Self::Messages>>) -> Self::OnMessage;

    /// Returned Future for the handle_reply method
    type OnResponse: Future<Output = Result<()>> + Send + 'a;

    /// Handle replies generated by an application. These typically should be sent to some client.
    fn on_response(&'a mut self, message: Message<Response>) -> Self::OnResponse;

    fn can_accept_requests(&self) -> bool {
        true
    }

    // Return type for on_request
    type OnRequest: Future<Output = Result<()>> + Send + 'a;
    /// Handle requests from clients.
    fn on_request(&'a mut self, request: Proposal) -> Self::OnRequest;

    /// Events generated by the protocol itself
    type OnEvent: Future<Output = Result<()>> + Send + 'a;
    /// Handle events generated by the protocol implementation itself. The framework will poll the Stream implementation of the protocol and call this method for every event. This is not strictly necessary, but is easiert to program with:
    /// event = self.protocol.select_next_some() => {
    ///     self.protocol.on_event(event).await?
    /// }
    fn on_event(&'a mut self, event: Self::Event) -> Self::OnEvent;
}

#[derive(Debug, PartialEq, Clone)]
pub enum Event<T> {
    Reorder(Proposal),
    Protocol(T),
}

/// Worker that read receives messages from clients and other replicas and passes them to the
/// protocol implementation
#[derive(Debug)]
pub struct ProtocolWorker<T: Protocol> {
    protocol: T,
    replicas: Receiver<Message<Raw<T::Messages>>>,
    clients: Receiver<Message<Raw<Client>>>,
    application: Receiver<Message<Response>>,
}

impl<T> ProtocolWorker<T>
where
    for<'a> T: Protocol2<'a>,
    T::Item: Send,
{
    pub fn new(
        protocol: T,
        replicas: Receiver<Message<Raw<T::Messages>>>,
        clients: Receiver<Message<Raw<Client>>>,
        application: Receiver<Message<Response>>,
    ) -> Self {
        Self {
            protocol,
            replicas,
            clients,
            application,
        }
    }

    pub async fn execute(mut self, batching: bool, config: BatchConfig) -> Result<()> {
        let proposal_stream = if batching {
            Batcher::new(
                self.clients
                    .filter_map(|req| ready(req.unpack::<Request>().ok())),
                config,
            )
            .left_stream()
        } else {
            self.clients
                .filter_map(|req| ready(req.unpack::<Request>().ok()))
                .map(Proposal::Single)
                .right_stream()
        };

        let mut replicas = self.replicas.fuse();
        let mut application = self.application.fuse();
        let mut proposal_stream = proposal_stream.fuse();

        loop {
            let result = tokio::select! {
                Some(event) = self.protocol.next() => Self ::handle_event(&mut self.protocol, event).await,
                Some(batch) = proposal_stream.next(), if self.protocol.can_accept_requests() => self.protocol.on_request(batch).await,
                Some(replica_msg) = replicas.next() => self.protocol.on_message(replica_msg).await,
                Some(response) = application.next() => self.protocol.on_response(response).await,
                else => break,
            };
            match result {
                Ok(_) => {}
                Err(Error::Reject(rejection)) => {
                    tracing::trace!(%rejection, "Message Rejected");
                }
                Err(e) => return Err(e),
            }
        }
        Ok(())
    }

    async fn handle_event(protocol: &mut T, event: Event<T::Event>) -> Result<()> {
        match event {
            Event::Reorder(proposal) => {
                tracing::warn!("reorder event");
                protocol.on_request(proposal).await?;
            }
            Event::Protocol(event) => protocol.on_event(event).await?,
        }
        Ok(())
    }
}

/// This is basically a copy of std::cmp::PartialEq
/// This exists because we need to differentiate between message that are equal,
/// e.i. the same message from the same replica with the same content,
/// and messages that "vote" for the same thing, e.g. the same content from different replicas.
pub trait Match<Rhs = Self>: PartialEq + Debug
where
    Rhs: ?Sized,
{
    fn matches(&self, other: &Rhs) -> bool;
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[repr(u8)]
pub enum ProtocolTag<T = Agnostic> {
    Checkpoint,
    Protocol(T),
}

impl<T> PartialEq<T> for ProtocolTag<T>
where
    T: PartialEq,
{
    fn eq(&self, other: &T) -> bool {
        match self {
            Self::Checkpoint => false,
            ProtocolTag::Protocol(t) => t == other,
        }
    }
}

impl<T> Tag for ProtocolTag<T>
where
    T: Tag,
{
    fn requires_signing(&self) -> Option<crate::net::AuthenticationKind> {
        match self {
            ProtocolTag::Checkpoint => Some(AuthenticationKind::Framework),
            ProtocolTag::Protocol(t) => t.requires_signing(),
        }
    }

    fn requires_validation(&self) -> Option<crate::net::AuthenticationKind> {
        match self {
            ProtocolTag::Checkpoint => Some(AuthenticationKind::Framework),
            ProtocolTag::Protocol(t) => t.requires_validation(),
        }
    }
}

pub type Framework = ProtocolTag<Agnostic>;

#[derive(Copy, Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub enum Agnostic {}
impl Tag for Agnostic {
    fn requires_signing(&self) -> Option<AuthenticationKind> {
        Some(AuthenticationKind::Framework)
    }

    fn requires_validation(&self) -> Option<AuthenticationKind> {
        Some(AuthenticationKind::Framework)
    }
}

#[cfg(test)]
mod test {
    use bytes::Bytes;
    use futures_util::stream::{iter, StreamExt};

    use crate::{
        app::{Client, Request},
        net::{Message, Raw},
        Result,
    };

    #[test]
    fn test_message() -> Result<()> {
        let p: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 8, 9];
        let bytes = Bytes::from(p);
        let r = Request::new(0, bytes);
        let m = Message::new(0, 0, r);
        let _mc = m.clone();
        let ms: Message<Raw<Client>> = m.pack()?;
        let vec = rmp_serde::to_vec(&ms)?;

        let m2: Message<Raw<Client>> = rmp_serde::from_slice(&vec).unwrap();
        let m3: Message<Request> = m2.unpack()?;

        assert_eq!(m, m3);
        Ok(())
    }

    #[tokio::test]
    #[cfg_attr(miri, ignore)]
    async fn test_select() {
        let f = || iter(std::iter::once(3));
        let mut s = f().fuse();
        loop {
            tokio::select! {
                Some(_) = s.next() => {}
                else => break
            }
        }
    }
}

mod error_impls {
    use crate::comms::SendError;

    macro_rules! impl_from {
        ($error:ty) => {
            impl From<$error> for super::Error {
                fn from(e: $error) -> Self {
                    Self::abort(e)
                }
            }
        };
    }

    impl_from!(SendError);
    impl_from!(rmp_serde::decode::Error);
    impl_from!(rmp_serde::encode::Error);
    impl_from!(crate::error::Error);
}
